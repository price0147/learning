# 策略模式
    这个部分没有什么好说的看代码,看注释.
# 观察者模式

    代码里面我只实现了观察者模式的推数据.而并未实现拉数据的方式;<br>
    1.推模式:数据更新以后,无论观察者需不需要所有的更新数据,主题都会把更新数据发给你<br>
    2.拉模式:我只提醒你更新了,你需要什么数据自己从我的set方法中获取.

## 注意

    观察则模式在java中有封装,但是主题的类不是一个接口而是一个类.
    所以我们不能用实现而需要用继承,集体实现方法我们这里面没有实现<br>
    原因:java提供的工具只能用集成这导致出现了很多局限性<br>
    比如:如果主题类还需要集成其他类,就不适用,因为java不支持多继承等等,所以我们还是推荐自己写毕竟不是很麻烦

# 装饰着模式
    这个模式的原则就是基本的"开闭原则",对某些方法的或者类的增强.
    
    问题:
        既然是另一个类的增强类,那为什么不直接用继承.
        答:可以用继承但是要秉持着多用组合少用继承的原则,
        而且继承会出现子类并不想要父类的方法或是属性的情况,
        提起这个问题就又回到了策略模式上,我们曾经提及过组合要比继承更灵活,
        继承的子类，实际上需要编译期确定下来，这满足不了需要在运行内才能确定对象的情况。
        而组合却可以比继承灵活得多，可以在运行期才决定某个对象。(目前的个人理解)
      
      优点:不需要动原有的代码.
      缺点:修饰者一点多了,就回造成程序里有很多很多小类(修饰者),从而也会增加系统的复杂度.
 
# 工厂模式
## 简单工厂模式
    简单工厂模式:他就像书里说的他不是一个真正意义上的模式.
    就是把判断要获取什么对象的逻辑的代码单独抽出来,
    如果将来需要修改的时候只需要修改一处地方.
## 工厂方法模式
    需要单个对象的时候适合使用工厂方法模式.
## 抽象工厂模式
    需要大批量对象时用它,他的解耦性没有工厂方法强.
# 单例模式
    单例模式的实现方式还是很简单的,详情请看代码.
    示例代码中我没有涉及到线程问题.详情请参考headfirst设计模式